<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Clione: Buccal Cone Hunt (iPhone縦版)</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0e2a40">
<style>
  :root { --glass: rgba(0,0,0,.45); --txt:#fff; }
  html, body { height: 100%; margin: 0; background: radial-gradient(1200px 600px at 50% 0%, #0e2a40 0%, #06131b 70%); color: var(--txt); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; }
  .safe { padding: max(12px, env(safe-area-inset-top)) max(12px, env(safe-area-inset-right)) max(12px, env(safe-area-inset-bottom)) max(12px, env(safe-area-inset-left)); }
  .wrap { display:flex; flex-direction:column; align-items:center; gap:10px; }
  h1 { margin: 4px 0 0; font-size: 20px; }
  .sub { opacity:.85; font-size: 14px; text-align:center; }
  .board { position:relative; width:min(100%, 420px); aspect-ratio:9/16; border-radius:16px; overflow:hidden; background:#000; box-shadow:0 10px 30px rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.08); touch-action:none; }
  canvas { width:100%; height:100%; display:block; }
  .hud { pointer-events:none; position:absolute; top:6px; left:6px; right:6px; display:flex; justify-content:space-between; gap:6px; font-weight:700; flex-wrap:wrap; }
  .pill { background:var(--glass); backdrop-filter: blur(5px); padding:6px 10px; border-radius:12px; border:1px solid rgba(255,255,255,.08); }
  .overlay { position:absolute; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.6); backdrop-filter: blur(4px); }
  .card { max-width: 320px; text-align:center; padding:16px; border-radius:16px; background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.08); }
  .controls { position:absolute; left:0; right:0; bottom:6px; display:flex; justify-content:center; gap:8px; }
  button { appearance:none; border:none; cursor:pointer; padding:12px 16px; border-radius:999px; font-weight:800; box-shadow:0 6px 16px rgba(0,0,0,.25); }
  .btn { background:#fff; color:#000; } .btn-g{background:#86efac;color:#000;} .btn-r{background:#fca5a5;color:#000;} .btn-k{background:#000;color:#fff;border:1px solid rgba(255,255,255,.2);}
  .combo { pointer-events:none; position:absolute; top:44px; left:50%; transform:translateX(-50%); text-align:center; }
  .bar { margin-top:4px; height:4px; width:120px; border-radius:999px; background:rgba(255,255,255,.2); overflow:hidden; }
  .bar>i { display:block; height:100%; background:#fff; width:0%; }
  .footer { font-size:12px; opacity:.75; text-align:center; }
  .stunFlash { position:absolute; inset:0; background:rgba(255,0,64,.18); pointer-events:none; opacity:0; transition:opacity .18s ease; }
  .stunFlash.on { opacity:1; }
</style>
</head>
<body>
<div class="safe">
  <div class="wrap">
    <div style="text-align:center">
      <h1>Clione: Buccal Cone Hunt</h1>
      <div class="sub">画面ドラッグで移動・<b>Attack</b>でバッカルコーン（外付けKBはSpace）。</div>
    </div>

    <div class="board" id="board">
      <canvas id="cv"></canvas>
      <div class="stunFlash" id="stunFx"></div>

      <div class="hud">
        <div class="pill">Score: <b id="sc">0</b></div>
        <div class="pill">Time: <b id="tm">60</b>s</div>
        <div class="pill">Best: <b id="bs">0</b></div>
        <div class="pill" id="status">Status: <b id="st">OK</b></div>
      </div>

      <div class="combo" id="comboWrap" style="display:none">
        <div class="pill" style="display:inline-block;background:rgba(244,63,94,.8);">Combo x<b id="cx">0</b></div>
        <div class="bar"><i id="cb" style="width:0%"></i></div>
      </div>

      <div class="overlay" id="ovl">
        <div class="card">
          <h2 style="margin:0 0 6px;font-size:18px;">遊び方</h2>
          <p style="margin:0 0 10px;opacity:.9;font-size:14px;">画面ドラッグでクリオネが泳ぎます。<br>下の <b>Attack</b> で捕食。連続ヒットでコンボ！<br>クラゲ（障害物）を<b>食べる</b>と2秒痺れます。</p>
          <button class="btn" id="start1">スタート</button>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="attack">Attack</button>
        <button class="btn-g" id="start">スタート</button>
        <button class="btn-k" id="help">ヘルプ</button>
      </div>
    </div>

    <div class="footer">iPhone向け単一HTML。GitHub Pagesで公開してください。</div>
  </div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const board = document.getElementById('board');
  const ctx = cv.getContext('2d');

  const sc = document.getElementById('sc');
  const tm = document.getElementById('tm');
  const bs = document.getElementById('bs');

  const comboWrap = document.getElementById('comboWrap');
  const cx = document.getElementById('cx');
  const cb = document.getElementById('cb');

  const ovl = document.getElementById('ovl');
  const start1 = document.getElementById('start1');
  const start = document.getElementById('start');
  const help = document.getElementById('help');
  const attack = document.getElementById('attack');

  const stunFx = document.getElementById('stunFx');
  const stTxt = document.getElementById('st');

  let running = false, score = 0, best = 0, timeLeft = 60;
  let lastTs = 0, lastSpawn = 0, spawnInterval = 1050;
  let timerId = null, req = 0;
  let comboCnt = 0, comboDecay = 0;
  const COMBO_WINDOW = 1200;

  let stunMs = 0; // スタン残り時間(ms)

  const game = {
    w: 360, h: 640,
    cl: { x: 180, y: 360, vx:0, vy:0, ang: -Math.PI/2, sp:3.2, fr:0.93, cone:{active:false, t:0, maxLen:96, cd:0} },
    prey: [], parts: [], haz: []
  };

  function resize() {
    const dpr = Math.min(window.devicePixelRatio||1, 2);
    const rect = board.getBoundingClientRect();
    game.w = Math.floor(rect.width);
    game.h = Math.floor(rect.height);
    cv.width = Math.floor(game.w * dpr);
    cv.height = Math.floor(game.h * dpr);
    cv.style.width = game.w + 'px';
    cv.style.height = game.h + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // タッチ移動（スタン中は無効）
  (function touchCtl(){
    let touching=false, tx=0, ty=0;
    function pos(e){ const r=cv.getBoundingClientRect(); const t=(e.touches&&e.touches[0])||e; return {x:t.clientX-r.left, y:t.clientY-r.top}; }
    cv.addEventListener('touchstart', e=>{ touching=true; ({x:tx,y:ty}=pos(e)); e.preventDefault(); }, {passive:false});
    cv.addEventListener('touchmove',  e=>{ if(!touching) return; ({x:tx,y:ty}=pos(e)); e.preventDefault(); }, {passive:false});
    cv.addEventListener('touchend',   e=>{ touching=false; e.preventDefault(); }, {passive:false});
    (function tick(){
      if(touching && running && stunMs<=0){
        const cl=game.cl; const dx=tx-cl.x, dy=ty-cl.y; const L=Math.hypot(dx,dy)||1;
        cl.vx+=(dx/L)*0.62; cl.vy+=(dy/L)*0.62; // 加速やや強め
        cl.ang=Math.atan2(dy,dx);
      }
      requestAnimationFrame(tick);
    })();
  })();

  // キーボード（外付け）
  const keys = Object.create(null);
  addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key===' ') e.preventDefault(); });
  addEventListener('keyup',   e => keys[e.key.toLowerCase()] = false);

  function vibrate(p){ if(navigator.vibrate){ try{ navigator.vibrate(p); }catch(e){} } }

  function startGame(){
    score=0; timeLeft=60; lastTs=0; lastSpawn=0; spawnInterval=1050;
    comboCnt=0; comboDecay=0; comboWrap.style.display='none';
    stunMs=0; stunFx.classList.remove('on'); stTxt.textContent='OK';
    const cl=game.cl; cl.x=game.w*0.5; cl.y=game.h*0.65; cl.vx=cl.vy=0; cl.ang=-Math.PI/2; cl.cone.active=false; cl.cone.t=0; cl.cone.cd=0;
    game.prey.length=0; game.parts.length=0; game.haz.length=0;
    running=true; ovl.style.display='none'; start.textContent='一時停止';
    sc.textContent=score; tm.textContent=timeLeft;
    if(timerId) clearInterval(timerId);
    timerId=setInterval(()=>{ if(!running) return; timeLeft--; if(timeLeft<=0){ timeLeft=0; endGame(); } tm.textContent=timeLeft; },1000);
    req=requestAnimationFrame(loop);
  }
  function endGame(){ running=false; ovl.style.display='grid'; best=Math.max(best,score); bs.textContent=best; start.textContent='スタート'; if(timerId){ clearInterval(timerId); timerId=null; } }

  function doAttack(){
    if(stunMs>0) return; // スタン中は攻撃不可
    const c=game.cl.cone; if(c.cd>0||c.active) return;
    c.active=true; c.t=0; c.cd=220; vibrate(8);
  }
  attack.addEventListener('click', e=>{ e.preventDefault(); doAttack(); });
  attack.addEventListener('touchstart', e=>{ e.preventDefault(); doAttack(); }, {passive:false});

  start1.addEventListener('click', startGame);
  start.addEventListener('click', ()=>{ if(!running) startGame(); else { running=false; start.textContent='スタート'; } });
  help.addEventListener('click', ()=>{ ovl.style.display = (ovl.style.display==='none'?'grid':'none'); });

  // スポーン：獲物と障害物
  function spawnPrey(){
    const t=Math.random();
    if(t<0.7){
      const x=30+Math.random()*(game.w-60), y=-30, sp=0.9+Math.random()*1.3;
      game.prey.push({x,y,r:10+Math.random()*12,vx:(Math.random()-0.5)*0.6,vy:sp,w:Math.random()*Math.PI*2,a:true});
    } else {
      const L=Math.random()<0.5, x=L?-30:game.w+30, y=60+Math.random()*(game.h-180), sp=0.9+Math.random()*1.2;
      game.prey.push({x,y,r:10+Math.random()*12,vx:L?sp:-sp,vy:(Math.random()-0.5)*0.6,w:Math.random()*Math.PI*2,a:true});
    }
  }
  function spawnHazard(){
    // クラゲ風：中心・傘・触手。プレイヤーのコーンで食べるとスタン
    const x=30+Math.random()*(game.w-60), y=-40, sp=0.5+Math.random()*0.8, r=14+Math.random()*10;
    game.haz.push({x,y,r, vx:(Math.random()-0.5)*0.4, vy:sp, phase:Math.random()*Math.PI*2, a:true});
  }

  function parts(x,y){
    for(let i=0;i<12;i++){
      const a=Math.random()*Math.PI*2, sp=Math.random()*2+0.5;
      game.parts.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:1});
    }
  }

  function computeBonus(cnt){ return Math.floor(cnt/5); }

  function handleKeys(){
    if(stunMs>0) return; // スタン中は入力無効
    const k=keys, cl=game.cl, A=0.42; // 係数をやや強め
    if(k[' ']) doAttack();
    if(k['arrowleft']||k['a'])  cl.vx-=cl.sp*A;
    if(k['arrowright']||k['d']) cl.vx+=cl.sp*A;
    if(k['arrowup']||k['w'])    cl.vy-=cl.sp*A;
    if(k['arrowdown']||k['s'])  cl.vy+=cl.sp*A;
  }

  function updatePhysics(dt){
    const cl=game.cl;
    // スタン減衰
    if(stunMs>0){
      stunMs -= dt;
      if(stunMs<=0){ stunMs=0; stTxt.textContent='OK'; stunFx.classList.remove('on'); }
    }
    // 減衰＆移動
    cl.vx*=cl.fr; cl.vy*=cl.fr;
    if(stunMs<=0){ cl.x+=cl.vx; cl.y+=cl.vy; } // スタン中は慣性のみでもOKにするならここで抑止
    cl.x=Math.max(22, Math.min(game.w-22, cl.x));
    cl.y=Math.max(22, Math.min(game.h-22, cl.y));
    if((cl.vx||cl.vy) && stunMs<=0) cl.ang=Math.atan2(cl.vy,cl.vx);
  }

  function updateCone(dt){
    const c=game.cl.cone;
    if(c.cd>0) c.cd-=dt;
    if(c.active){
      c.t+=dt/200;
      if(c.t>=1){ c.t=1; c.active=false; c.cd=Math.max(c.cd,150); }
    } else if(c.t>0){
      c.t-=dt/320;
      if(c.t<0) c.t=0;
    }
  }

  function onHitPrey(x,y){
    parts(x,y);
    comboCnt++;
    comboDecay=COMBO_WINDOW;
    comboWrap.style.display='block';
    cx.textContent=comboCnt;
    const bonus=computeBonus(comboCnt);
    score += 1+bonus;
    sc.textContent=score;
    vibrate([12,40,12]);
  }

  function onHitHazard(x,y){
    // スタン発動
    stunMs = 2000;
    stTxt.textContent='STUN!';
    stunFx.classList.add('on');
    setTimeout(()=>stunFx.classList.remove('on'), 120);
    vibrate([30,60,30]);
  }

  function checkCollisions(){
    const cl=game.cl, c=cl.cone;
    if(c.t<=0.05) return;
    const len=c.maxLen*c.t;
    const tipX=cl.x+Math.cos(cl.ang)*(28+len), tipY=cl.y+Math.sin(cl.ang)*(28+len);
    // prey
    for(const p of game.prey){
      if(!p.a) continue;
      const dx=p.x-tipX, dy=p.y-tipY;
      if(dx*dx+dy*dy<(p.r+10)*(p.r+10)){ p.a=false; onHitPrey(p.x,p.y); }
    }
    // hazards（食べる＝コーン接触でスタン）
    for(const h of game.haz){
      if(!h.a) continue;
      const dx=h.x-tipX, dy=h.y-tipY;
      if(dx*dx+dy*dy<(h.r+10)*(h.r+10)){
        h.a=false; onHitHazard(h.x,h.y);
        // 攻撃をキャンセルしてクールダウン
        c.active=false; c.t=0; c.cd=Math.max(c.cd,280);
      }
    }
  }

  // 背景
  function bg(){
    const g=ctx.createLinearGradient(0,0,0,game.h);
    g.addColorStop(0,'#0b1f2e'); g.addColorStop(1,'#06131b');
    ctx.fillStyle=g; ctx.fillRect(0,0,game.w,game.h);
    ctx.globalAlpha=.15;
    for(let i=0;i<38;i++){
      const x=(i*37+(Date.now()/9))%game.w, y=((i*101)%game.h)+Math.sin((Date.now()/900)+i)*8;
      ctx.beginPath(); ctx.arc(x,y,(i%6)+1,0,Math.PI*2);
      ctx.fillStyle='#9dd0ff'; ctx.fill();
    }
    ctx.globalAlpha=1;
  }

  // クリオネ（本物寄り質感）
  function drawCl(){
    const cl=game.cl;
    ctx.save();
    ctx.translate(cl.x,cl.y);
    ctx.rotate(cl.ang);

    // 半透明ボディ
    ctx.beginPath();
    ctx.ellipse(0,0,22,30,0,0,Math.PI*2);
    const body=ctx.createRadialGradient(-4,-8,5, 0,0,36);
    body.addColorStop(0,'rgba(255,255,255,.95)');
    body.addColorStop(0.55,'rgba(255,180,200,.25)');
    body.addColorStop(1,'rgba(180,210,255,.08)');
    ctx.fillStyle=body; ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.lineWidth=1.2; ctx.stroke();

    // 内臓コア（オレンジ寄り）
    ctx.beginPath();
    ctx.ellipse(-3,0,6,10,0,0,Math.PI*2);
    const core=ctx.createRadialGradient(-5,-2,1, -3,0,12);
    core.addColorStop(0,'rgba(255,180,120,.85)');
    core.addColorStop(1,'rgba(255,150,150,.15)');
    ctx.fillStyle=core; ctx.fill();

    // 翼（拍動）
    ctx.save();
    const flap=Math.sin(Date.now()/140)*0.45;
    ctx.rotate(flap);
    ctx.beginPath();
    ctx.ellipse(-8,12,16,7,-.55,0,Math.PI*2);
    ctx.ellipse(-8,-12,16,7,.55,0,Math.PI*2);
    ctx.fillStyle='rgba(255,200,210,.35)'; ctx.fill();
    ctx.restore();

    // バッカルコーン（半透明グラデ）
    if(cl.cone.t>0){
      const t=cl.cone.t, len=10+cl.cone.maxLen*t, w=6+10*(1-t);
      ctx.beginPath();
      ctx.moveTo(18,-w*.5);
      ctx.quadraticCurveTo(18+len*.5,-w,18+len,0);
      ctx.quadraticCurveTo(18+len*.5,w,18,w*.5);
      const g=ctx.createLinearGradient(18,0,18+len,0);
      g.addColorStop(0,'rgba(255,170,180,.55)');
      g.addColorStop(1,'rgba(255,110,130,.92)');
      ctx.fillStyle=g; ctx.fill();
      ctx.strokeStyle='rgba(255,160,170,.85)'; ctx.lineWidth=1; ctx.stroke();

      // 鋸歯
      ctx.beginPath();
      for(let i=0;i<5;i++){
        const t2=i/4;
        const px=18+len*(.7+.25*t2);
        const py=(i%2===0?-1:1)*(w*.4+i*.4);
        ctx.moveTo(px,-py);
        ctx.lineTo(px+6,-py*1.1);
      }
      ctx.strokeStyle='rgba(255,200,200,.7)'; ctx.lineWidth=.6; ctx.stroke();
    }

    // 目
    ctx.beginPath();
    ctx.arc(-6,-6,1.6,0,Math.PI*2);
    ctx.arc(-6,6,1.6,0,Math.PI*2);
    ctx.fillStyle='rgba(80,80,120,.9)'; ctx.fill();

    // スタン中のトーンダウン
    if(stunMs>0){
      ctx.globalAlpha=.6;
      ctx.beginPath();
      ctx.ellipse(0,0,23,31,0,0,Math.PI*2);
      ctx.fillStyle='rgba(255,0,64,.08)'; ctx.fill();
    }

    ctx.restore();
  }

  function drawPrey(dt){
    for(const p of game.prey){
      if(!p.a) continue;
      p.x+=p.vx;
      p.y+=p.vy+Math.sin((Date.now()/300)+p.w)*.3;
      if(p.x<-60||p.x>game.w+60||p.y<-60||p.y>game.h+60) p.a=false;

      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fillStyle='#a9f5d0'; ctx.fill();
      ctx.strokeStyle='#7ad0aa'; ctx.stroke();

      ctx.beginPath();
      ctx.arc(p.x+p.r*.2,p.y-p.r*.2,Math.max(1,p.r*.15),0,Math.PI*2);
      ctx.fillStyle='#2a5a50'; ctx.fill();
    }

    // パーティクル
    for(const q of game.parts){
      q.x+=q.vx; q.y+=q.vy;
      q.vx*=.98; q.vy*=.98;
      q.life-=dt/900;
    }
    game.parts=game.parts.filter(q=>q.life>0);
    ctx.save(); ctx.globalAlpha=.7;
    for(const q of game.parts){
      ctx.beginPath(); ctx.arc(q.x,q.y,2,0,Math.PI*2);
      ctx.fillStyle='#ffd3d3'; ctx.fill();
    }
    ctx.restore();
  }

  function drawHazards(dt){
    for(const h of game.haz){
      if(!h.a) continue;
      h.x+=h.vx;
      h.y+=h.vy + Math.sin((Date.now()/500)+h.phase)*0.25;
      if(h.x<-80||h.x>game.w+80||h.y<-80||h.y>game.h+80) h.a=false;

      // 傘
      const grd=ctx.createRadialGradient(h.x,h.y-h.r*0.3,2, h.x,h.y, h.r*1.2);
      grd.addColorStop(0,'rgba(255,190,220,.85)');
      grd.addColorStop(1,'rgba(255,120,180,.15)');
      ctx.beginPath();
      ctx.ellipse(h.x,h.y,h.r*1.1,h.r*0.8,0,0,Math.PI*2);
      ctx.fillStyle=grd; ctx.fill();
      ctx.strokeStyle='rgba(255,160,200,.55)'; ctx.stroke();

      // 触手
      ctx.save();
      ctx.globalAlpha=.7;
      for(let i=0;i<5;i++){
        const a=(i-2)*0.18, len=h.r*1.6;
        ctx.beginPath();
        ctx.moveTo(h.x + Math.cos(a)*h.r*0.6, h.y + Math.sin(a)*h.r*0.4);
        ctx.quadraticCurveTo(h.x+Math.cos(a+0.4)*h.r*0.4, h.y+len*0.4, h.x+Math.cos(a+0.6)*h.r*0.2, h.y+len);
        ctx.strokeStyle='rgba(255,150,200,.4)';
        ctx.lineWidth=1;
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  function bgStep(ts, dt){
    // 背景・描画まとめ
    bg();
    drawPrey(dt);
    drawHazards(dt);
    drawCl();
    // スタン時の視覚効果（軽い点滅は .stunFlash で）
  }

  function loop(ts){
    if(!running) return;
    if(!lastTs) lastTs=ts;
    const dt=Math.min(34, ts-lastTs);
    lastTs=ts;

    // コンボバー
    if(comboDecay>0){
      comboDecay-=dt;
      const ratio=Math.max(0, Math.min(1, comboDecay/COMBO_WINDOW));
      cb.style.width=(ratio*100)+'%';
      if(comboDecay<=0){ comboCnt=0; comboWrap.style.display='none'; }
    }

    // スポーン（獲物 + 時々障害物）
    lastSpawn+=dt;
    if(lastSpawn>spawnInterval){
      lastSpawn=0;
      spawnPrey();
      if(Math.random()<0.28) spawnHazard(); // およそ28%でクラゲ
      spawnInterval=Math.max(420, spawnInterval-10);
    }

    // 入力・物理
    handleKeys();
    updatePhysics(dt);
    updateCone(dt);
    checkCollisions();

    // 描画
    bgStep(ts, dt);

    req=requestAnimationFrame(loop);
  }

  // メモリ掃除
  setInterval(()=>{ game.prey = game.prey.filter(p=>p.a); game.haz = game.haz.filter(h=>h.a); }, 1500);

  // 起動
  start1.addEventListener('click', startGame);
})();
</script>
</body>
</html>
